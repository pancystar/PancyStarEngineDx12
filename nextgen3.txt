1，描述符的内存堆做分级处理(64/32/16....)以减少bundless texture过少而对描述符内存的浪费(需要多个rootsignature)
2，为场景动画单独开辟顶点缓冲区用于computeshader更新(影响instance处理，待考虑)(转为开辟顶点动画缓冲区以兼容instance)
3，次表面散射
4，buffer单独开辟一个类
5，根据cbuffer和srv的反射名设置shader参数，并将cbuffer上传封装
6，资源分类:
7，外部资源，使用一个状态来标记当前资源的处理情况，包括(未加载，已加载至cpu，已拷贝至gpu)等
8，内部创建的动态逐帧中间件资源包括rtt的纹理以及cbuffer等一律创建两份以供交叉线程使用
9，枚举或运算反射
10，除资源管理器，其他类不再通过智能指针访问数据，减少消耗
11，各种不同json文件路径规划单例
12，资源管理器规划合适的堆内存删除方案(内存块类型的使用频率)
13,将最终的render object打包instance后的组件放在渲染队列类中
14，ID号转化为class，即能够方便实现智能指针，又可以方便的修改每个ID所占的字节数，保留empty和error以确定指针是否正确传入。
15，返回出错处理的函数要求上层函数传递log信息
16，允许创建独占一块buffer的subbuffer，防止出现分开创建的subbuffer一个用于读一个用于写的情况
17，shadermodel6.0支持short类型(目前程序编译使用的是5.1)，将顶点动画的解压缩指针数据用short存储可以节省一半的存储空间
18，引擎启动时先启动文件生成，将shader编译延迟到文件生成之后。
19,测试在已经开辟完毕的descriptorheap上创建view的速度，如果足够快，则不再保留每个物体的描述符信息，只需要保留一些渲染层信息即可，每一帧单独生成渲染队列并清空
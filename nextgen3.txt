1，描述符的内存堆做分级处理(64/32/16....)以减少bundless texture过少而对描述符内存的浪费(需要多个rootsignature)
1.solve：在19.solve中使用新的方案解决了此问题
2，为场景动画单独开辟顶点缓冲区用于computeshader更新(影响instance处理，待考虑)(转为开辟顶点动画缓冲区以兼容instance)
3，次表面散射
4，buffer单独开辟一个类
5，根据cbuffer和srv的反射名设置shader参数，并将cbuffer上传封装
6，资源分类:
7，外部资源，使用一个状态来标记当前资源的处理情况，包括(未加载，已加载至cpu，已拷贝至gpu)等
8，内部创建的动态逐帧中间件资源包括rtt的纹理以及cbuffer等一律创建两份以供交叉线程使用
9，枚举或运算反射
10，除资源管理器，其他类不再通过智能指针访问数据，减少消耗
11，各种不同json文件路径规划单例
12，资源管理器规划合适的堆内存删除方案(内存块类型的使用频率)
13,将最终的render object打包instance后的组件放在渲染队列类中
14，ID号转化为class，即能够方便实现智能指针，又可以方便的修改每个ID所占的字节数，保留empty和error以确定指针是否正确传入。
15，返回出错处理的函数要求上层函数传递log信息
16，允许创建独占一块buffer的subbuffer，防止出现分开创建的subbuffer一个用于读一个用于写的情况
16.solve：使用commit resource彻底放弃以往对于buffer数据的内存池管理，保留texture的内存堆，使用ring-buffer处理所有的动态资源。
17，shadermodel6.0支持short类型(目前程序编译使用的是5.1)，将顶点动画的解压缩指针数据用short存储可以节省一半的存储空间
18，引擎启动时先启动文件生成，将shader编译延迟到文件生成之后。
19，测试在已经开辟完毕的descriptorheap上创建view的速度，如果足够快，则不再保留每个物体的描述符信息，只需要保留一些渲染层信息即可，每一帧单独生成渲染队列并清空
19.solve：使用段页式管理以及全局描述符与局部描述符分割的方式解决了这个问题
20，多线程资源加载，基于委托的资源管理器
21，预研如何将动画的骨骼计算部分组合起来通过CS实现动画的骨骼生成
22，json反射，设定一个用于继承的基类，该基类能够自动的完成自身对象到json的序列化(前提是实现虚构函数中关于各个变量的注册)，为了兼容dx以及其他API的自定义结构，基类需要保证能够解析最基本的九种结构(int,float,string,bool,以及他们的vector格式，以及所有enum类型)
23, 资源创建阶段就设定号创建几份(根据帧)，这样再创建描述符时不需要再额外考虑多缓存的问题。
24，indirect draw
25，gpu driven pipeline